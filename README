What this project does
Frontend: form.html — HTML5 form (required/type/min) + tiny JS to submit.

Backend: app.py (FastAPI) — serves the form and calls Python validators.

Business rules: logic/validations.py — name/email/age checks (single source of truth).

What each test layer covers
Unit tests (pytest) → Backend rules
File: tests/test_validations.py

Test the Python validators directly (no browser, no server).

Fast, exhaustive edge cases: invalid ages, emails, names, types, boundaries.

Selenium (pytest) → End-to-end UI
File: selenium_test/test_form_selenium.py

Drive a real browser against http://127.0.0.1:8000/.

Happy path: valid input → POST → backend 200 → green success banner.

Backend reject: input that passes HTML5 but fails server rules (e.g., akram@domain, age=121) → POST → backend 400 → red error banner.

HTML5-blocked case: malformed email (e.g., akram_at_example.com) → no POST → browser blocks submit; banner stays unchanged.

Robot Framework → Acceptance scenarios
File: robot_tests/form_tests.robot
Business-readable flows (happy path + one invalid).

Minimal overlap with Selenium; focuses on readable specs.

How the flow works :
Browser (form.html)
 └─ click Submit
    ├─ If HTML5 invalid → NO POST (browser tooltip/outline)
    └─ If HTML5 valid   → POST /submit (JSON)
                           FastAPI (app.py) → validations.py
                             ├─ OK  → 200 → “Form submitted successfully”
                             └─ ERR → 400 → “Invalid …” (from validator)

How to use the repo :
You can execute the run_tests_all.ps1 script, this will :
- starts the FastAPI backend on http://127.0.0.1:8000/
- runs unit (pytest), Selenium (pytest), and Robot tests
- writes results into allure-results/
- serves the Allure report in your browser
